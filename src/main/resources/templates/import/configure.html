<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.thymeleaf.org"
      th:replace="~{layout/main :: html(
        'Настройка импорта - Обработка файлов',
        ~{::section},
        ~{::script},
        ~{::style},
        'Настройка импорта файла ' + ${fileName},
        ~{::.page-actions}
      )}">
<head>
    <title>Настройка импорта - Обработка файлов</title>
    <style>
        .file-info-container {
            background-color: #f8f9fa;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .file-name {
            font-weight: bold;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
        }

        .file-name i {
            margin-right: 0.5rem;
        }

        .file-details {
            color: #6c757d;
            margin-top: 0.5rem;
        }

        .mapping-card {
            border: 1px solid rgba(0, 0, 0, .125);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }

        .mapping-card:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .mapping-card.selected {
            border-color: #007bff;
            background-color: #f1f8ff;
        }

        .mapping-card.create-new {
            border-style: dashed;
            text-align: center;
            cursor: pointer;
        }

        .mapping-header {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .mapping-title {
            font-weight: bold;
            margin-right: auto;
        }

        .mapping-radio {
            margin-left: 1rem;
        }

        .mapping-description {
            color: #6c757d;
            margin-bottom: 0.5rem;
        }

        .mapping-details {
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }

        .table-scroll {
            max-height: 300px;
            overflow-y: auto;
        }

        .sticky-header th {
            position: sticky;
            top: 0;
            background-color: #f8f9fa;
            z-index: 1;
        }

        .mapping-table {
            margin-top: 1.5rem;
        }

        .mapping-table select {
            width: 100%;
        }

        .source-header {
            background-color: #f1f8ff;
        }

        .target-header {
            background-color: #f8f1ff;
        }

        .header-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .source-indicator {
            background-color: #007bff;
        }

        .target-indicator {
            background-color: #6f42c1;
        }

        .import-options {
            margin-top: 2rem;
        }

        .sample-data-container {
            margin-top: 1.5rem;
        }

        .tab-content {
            padding-top: 1.5rem;
        }
    </style>
</head>
<body>
<!-- Действия страницы -->
<div class="page-actions">
    <a th:href="@{/import/{clientId}(clientId=${client.id})}" class="btn btn-secondary">
        <i class="fas fa-arrow-left me-1"></i>Назад к загрузке
    </a>
</div>

<section>
    <!-- Информация о файле -->
    <div class="file-info-container">
        <div class="file-name">
            <i class="fas fa-file-alt text-primary"></i>
            <span th:text="${fileName}">filename.csv</span>
        </div>
        <div class="file-details">
            <span th:text="${fileSize}">1.2 MB</span> |
            <span th:text="${analysis.processorType}">CSV Processor</span> |
            <span th:if="${analysis.estimatedRows != null}">
                Примерно <span th:text="${analysis.estimatedRows}">100</span> записей
            </span>
        </div>
    </div>

    <!-- Форма импорта -->
    <form id="importForm" th:action="@{/import/{clientId}/import(clientId=${client.id})}" method="post"
          enctype="multipart/form-data">
        <!-- Скрытое поле для файла -->
        <input type="hidden" name="tempFilePath" th:value="${tempFilePath}"/>
        <input type="hidden" name="fileName" th:value="${fileName}"/>

        <!-- Добавляем правильную обработку флажка сохранения маппинга -->
        <script>
            document.addEventListener('DOMContentLoaded', function () {
                const saveMapping = document.getElementById('saveMapping');
                const saveMappingOptions = document.getElementById('saveMappingOptions');

                if (saveMapping && saveMappingOptions) {
                    saveMapping.addEventListener('change', function () {
                        saveMappingOptions.style.display = this.checked ? 'block' : 'none';
                    });
                }

                // Также необходимо убедиться, что при отправке формы с выбранным "new" и не выбранным
                // saveMapping, параметр mappingName будет установлен в значение по умолчанию
                const importForm = document.getElementById('importForm');
                if (importForm) {
                    importForm.addEventListener('submit', function (e) {
                        const mappingId = document.querySelector('input[name="mappingId"]:checked')?.value;
                        const saveMapping = document.getElementById('saveMapping')?.checked;

                        if (mappingId === 'new' && saveMapping) {
                            const mappingName = document.getElementById('mappingName')?.value;
                            if (!mappingName || mappingName.trim() === '') {
                                e.preventDefault();
                                alert('Пожалуйста, укажите название для новой схемы маппинга');
                            }
                        }
                    });
                }
            });
        </script>

        <!-- Вкладки настройки -->
        <ul class="nav nav-tabs" id="importTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="mapping-tab" data-bs-toggle="tab" data-bs-target="#mapping"
                        type="button" role="tab" aria-controls="mapping" aria-selected="true">
                    <i class="fas fa-map-signs me-1"></i>Сопоставление полей
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="sample-tab" data-bs-toggle="tab" data-bs-target="#sample"
                        type="button" role="tab" aria-controls="sample" aria-selected="false">
                    <i class="fas fa-table me-1"></i>Образец данных
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="options-tab" data-bs-toggle="tab" data-bs-target="#options"
                        type="button" role="tab" aria-controls="options" aria-selected="false">
                    <i class="fas fa-cogs me-1"></i>Настройки импорта
                </button>
            </li>
        </ul>

        <div class="tab-content" id="importTabsContent">
            <!-- Вкладка сопоставления полей -->
            <div class="tab-pane fade show active" id="mapping" role="tabpanel" aria-labelledby="mapping-tab">
                <div class="card mb-4">
                    <div class="card-body">
                        <h5 class="card-title">Выберите схему сопоставления полей</h5>

                        <!-- Список доступных маппингов -->
                        <div class="row">
                            <div class="col-md-6 mb-3" th:each="mapping : ${availableMappings}">
                                <div class="mapping-card" th:data-mapping-id="${mapping.id}">
                                    <div class="mapping-header">
                                        <div class="mapping-title" th:text="${mapping.name}">Default Mapping</div>
                                        <div class="mapping-radio">
                                            <input type="radio" th:id="'mapping_' + ${mapping.id}" name="mappingId"
                                                   th:value="${mapping.id}" class="form-check-input mapping-selector"/>
                                        </div>
                                    </div>
                                    <div class="mapping-description" th:text="${mapping.description}">
                                        Standard field mapping for product imports
                                    </div>
                                    <div class="mapping-details">
                                        <small th:text="'Полей: ' + ${mapping.fields_count}">12 fields</small>
                                        <small class="ms-2" th:if="${mapping.client_id == client.id}">
                                            <span class="badge bg-primary">Персональный</span>
                                        </small>
                                        <small class="ms-2" th:if="${mapping.client_id == null}">
                                            <span class="badge bg-secondary">Общий</span>
                                        </small>
                                    </div>
                                </div>
                            </div>

                            <!-- Создать новую схему сопоставления -->
                            <div class="col-md-6 mb-3">
                                <div class="mapping-card create-new" data-mapping-id="new">
                                    <div class="mapping-header">
                                        <div class="mapping-title">Создать новую схему</div>
                                        <div class="mapping-radio">
                                            <input type="radio" id="mapping_new" name="mappingId" value="new"
                                                   class="form-check-input mapping-selector"/>
                                        </div>
                                    </div>
                                    <div class="mapping-description">
                                        <i class="fas fa-plus-circle me-1"></i>Настроить собственную схему сопоставления
                                        полей
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Таблица сопоставления полей -->
                        <div id="mappingTableContainer" class="mapping-table">
                            <h5>Настройка сопоставления полей</h5>
                            <p class="text-muted">Укажите, каким полям сущности соответствуют поля из файла.</p>

                            <div class="d-flex align-items-center mb-2">
                                <div class="me-3">
                                    <span class="header-indicator source-indicator"></span>
                                    <strong>Поля из файла</strong>
                                </div>
                                <div>
                                    <span class="header-indicator target-indicator"></span>
                                    <strong>Поля сущности</strong>
                                </div>
                                <div class="ms-auto">
                                    <select id="entityTypeSelect" name="entityType" class="form-select form-select-sm"
                                            style="width: 200px;">
                                        <option value="product" selected>Товар (Product)</option>
                                        <option value="regiondata">Регион (RegionData)</option>
                                        <option value="competitordata">Конкурент (CompetitorData)</option>
                                        <option value="product_with_related">Товар с регионами и конкурентами</option>
                                    </select>
                                </div>
                            </div>

                            <div class="table-scroll">
                                <table class="table table-bordered table-hover">
                                    <thead class="sticky-header">
                                    <tr>
                                        <th class="source-header">Поле в файле</th>
                                        <th class="target-header">Поле сущности</th>
                                    </tr>
                                    </thead>
                                    <tbody id="mappingTableBody">
                                    <tr th:each="header, stat : ${analysis.headers}">
                                        <td class="source-header" th:text="${header}">Product Name</td>
                                        <td>
                                            <select th:name="'mapping[' + ${header} + ']'"
                                                    class="form-select entity-field-selector">
                                                <option value="">-- Не импортировать --</option>
                                                <!-- Опции будут заполнены динамически -->
                                            </select>
                                        </td>
                                    </tr>
                                    </tbody>
                                </table>
                            </div>

                            <!-- Сохранение схемы сопоставления -->
                            <div class="mt-3 form-check">
                                <input type="checkbox" class="form-check-input" id="saveMapping" name="saveMapping"
                                       value="true">
                                <label class="form-check-label" for="saveMapping">
                                    Сохранить эту схему сопоставления для будущего использования
                                </label>
                            </div>
                            <div id="saveMappingOptions" class="mt-2" style="display: none;">
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="mb-3">
                                            <label for="mappingName" class="form-label">Название схемы</label>
                                            <input type="text" class="form-control" id="mappingName" name="mappingName"
                                                   placeholder="Например: Импорт товаров из 1С">
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="mb-3">
                                            <label for="mappingDescription" class="form-label">Описание
                                                (опционально)</label>
                                            <input type="text" class="form-control" id="mappingDescription"
                                                   name="mappingDescription"
                                                   placeholder="Краткое описание схемы">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Вкладка образца данных -->
            <div class="tab-pane fade" id="sample" role="tabpanel" aria-labelledby="sample-tab">
                <div class="card mb-4">
                    <div class="card-body">
                        <h5 class="card-title">Образец данных из файла</h5>
                        <p class="text-muted">Показаны первые 10 строк из файла для предварительного просмотра.</p>

                        <div class="table-scroll">
                            <table class="table table-sm table-bordered">
                                <thead class="sticky-header">
                                <tr>
                                    <th>#</th>
                                    <th th:each="header : ${analysis.headers}" th:text="${header}">Header</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr th:each="row, rowStat : ${analysis.sampleData}">
                                    <td th:text="${rowStat.count}">1</td>
                                    <td th:each="header : ${analysis.headers}" th:text="${row[header]}">Value</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-info-circle me-2"></i>
                            <span th:if="${analysis.estimatedRows != null}">
                                Всего в файле примерно <strong th:text="${analysis.estimatedRows}">100</strong> записей
                            </span>
                            <span th:unless="${analysis.estimatedRows != null}">
                                Количество записей в файле не определено
                            </span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Вкладка настроек импорта -->
            <div class="tab-pane fade" id="options" role="tabpanel" aria-labelledby="options-tab">
                <div class="card mb-4">
                    <div class="card-body">
                        <h5 class="card-title">Настройки процесса импорта</h5>

                        <div class="row">
                            <!-- Общие настройки -->
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="processingStrategy" class="form-label">Стратегия обработки</label>
                                    <select class="form-select" id="processingStrategy" name="processingStrategy">
                                        <option value="insert" selected>Только вставка новых записей</option>
                                        <option value="update">Обновление существующих записей</option>
                                        <option value="upsert">Вставка новых и обновление существующих</option>
                                        <option value="replace">Замена всех существующих записей</option>
                                    </select>
                                    <div class="form-text">Определяет, как обрабатывать существующие записи</div>
                                </div>

                                <div class="mb-3">
                                    <label for="batchSize" class="form-label">Размер пакета</label>
                                    <select class="form-select" id="batchSize" name="batchSize">
                                        <option value="100">100 записей</option>
                                        <option value="500" selected>500 записей</option>
                                        <option value="1000">1000 записей</option>
                                        <option value="5000">5000 записей</option>
                                    </select>
                                    <div class="form-text">Количество записей, обрабатываемых за один раз</div>
                                </div>
                            </div>

                            <!-- Обработка ошибок -->
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="errorHandling" class="form-label">Обработка ошибок</label>
                                    <select class="form-select" id="errorHandling" name="errorHandling">
                                        <option value="stop">Остановить процесс при ошибке</option>
                                        <option value="continue" selected>Пропускать ошибочные записи и продолжать
                                        </option>
                                        <option value="report">Собирать ошибки в отчет и продолжать</option>
                                    </select>
                                    <div class="form-text">Определяет, что делать при обнаружении ошибки в записи</div>
                                </div>

                                <div class="mb-3">
                                    <label for="duplicateHandling" class="form-label">Обработка дубликатов</label>
                                    <select class="form-select" id="duplicateHandling" name="duplicateHandling">
                                        <option value="skip" selected>Пропускать дубликаты</option>
                                        <option value="update">Обновлять существующие записи</option>
                                        <option value="error">Выдавать ошибку при дубликате</option>
                                    </select>
                                    <div class="form-text">Определяет, что делать при обнаружении дублирующейся записи
                                    </div>
                                </div>
                            </div>
                        </div>

                        <h5 class="mt-4">Дополнительные параметры</h5>

                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3 form-check">
                                    <input type="checkbox" class="form-check-input" id="validateData"
                                           name="validateData" checked>
                                    <label class="form-check-label" for="validateData">
                                        Валидировать данные перед импортом
                                    </label>
                                </div>

                                <div class="mb-3 form-check">
                                    <input type="checkbox" class="form-check-input" id="trimWhitespace"
                                           name="trimWhitespace" checked>
                                    <label class="form-check-label" for="trimWhitespace">
                                        Удалять лишние пробелы в строковых полях
                                    </label>
                                </div>
                            </div>

                            <div class="col-md-6">
                                <div class="mb-3 form-check">
                                    <input type="checkbox" class="form-check-input" id="generateReport"
                                           name="generateReport" checked>
                                    <label class="form-check-label" for="generateReport">
                                        Генерировать отчет о результатах импорта
                                    </label>
                                </div>

                                <div class="mb-3 form-check">
                                    <input type="checkbox" class="form-check-input" id="notifyOnComplete"
                                           name="notifyOnComplete" checked>
                                    <label class="form-check-label" for="notifyOnComplete">
                                        Уведомить о завершении импорта
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Кнопки действий -->
        <div class="d-flex justify-content-between mt-4">
            <a th:href="@{/import/{clientId}(clientId=${client.id})}" class="btn btn-outline-secondary">
                <i class="fas fa-arrow-left me-1"></i>Назад
            </a>
            <button type="submit" class="btn btn-primary btn-lg">
                <i class="fas fa-file-import me-1"></i>Начать импорт
            </button>
        </div>
    </form>
</section>

<script th:inline="javascript">
    // Получаем метаданные полей из контроллера с резервными данными
    const serverEntityFieldsMetadata = /*[[${entityFieldsMetadata}]]*/ {};
    const supportedEntityTypes = /*[[${supportedEntityTypes}]]*/ [];

    // Получаем clientId из модели
    const clientId = /*[[${client.id}]]*/ 1;
    // Получаем текущий тип сущности из селектора
    let entityType = 'product'; // Значение по умолчанию

    // Создаем резервные данные на случай, если с сервера ничего не пришло
    const fallbackMetadata = {
        // Для обычного продукта
        "product": {
            "ID товара": "productId",
            "Модель": "productName",
            "Бренд": "productBrand",
            "Штрихкод": "productBar",
            "Описание": "productDescription",
            "Ссылка": "productUrl",
            "Категория товара 1": "productCategory1",
            "Категория товара 2": "productCategory2",
            "Категория товара 3": "productCategory3",
            "Цена": "productPrice",
            "Аналог": "productAnalog",
            "Дополнительное поле 1": "productAdditional1",
            "Дополнительное поле 2": "productAdditional2"
        },
        // Для региона
        "regiondata": {
            "Город": "region",
            "Адрес": "regionAddress"
        },
        // Для конкурента
        "competitordata": {
            "Сайт": "competitorName",
            "Цена конкурента": "competitorPrice",
            "Ссылка": "competitorUrl",
            "Наименование товара конкурента": "competitorProductName"
        },
        // Для продукта с связанными сущностями
        "product_with_related": {
            "Товар": [
                {"key": "ID товара", "value": "productId"},
                {"key": "Модель", "value": "productName"},
                {"key": "Бренд", "value": "productBrand"},
                {"key": "Штрихкод", "value": "productBar"},
                {"key": "Описание", "value": "productDescription"},
                {"key": "Ссылка", "value": "productUrl"}
            ],
            "Регион": [
                {"key": "Город", "value": "region"},
                {"key": "Адрес", "value": "regionAddress"}
            ],
            "Конкурент": [
                {"key": "Сайт", "value": "competitorName"},
                {"key": "Цена конкурента", "value": "competitorPrice"},
                {"key": "Ссылка", "value": "competitorUrl"}
            ]
        }
    };

    // Используем данные сервера, если они не пусты, иначе резервные данные
    const entityFieldsMetadata = (serverEntityFieldsMetadata && Object.keys(serverEntityFieldsMetadata).length > 0) ?
        serverEntityFieldsMetadata : fallbackMetadata;

    document.addEventListener('DOMContentLoaded', function () {
        console.log('=== Debug Information ===');
        console.log('Server EntityFieldsMetadata:', serverEntityFieldsMetadata);
        console.log('Fallback EntityFieldsMetadata:', fallbackMetadata);
        console.log('Actual EntityFieldsMetadata used:', entityFieldsMetadata);
        console.log('Supported Entity Types:', supportedEntityTypes);
        console.log('Client ID:', clientId);

        // Получаем текущий тип сущности из селектора
        entityType = document.getElementById('entityTypeSelect')?.value || 'product';
        console.log('Initial Entity Type:', entityType);
        console.log('========================');

        // Инициализация файла в форме
        initFileInput();

        // Обработка выбора схемы сопоставления
        initMappingSelectors();

        // Обработка изменения типа сущности
        initEntityTypeSelector();

        // Обработка флажка сохранения схемы
        initSaveMappingCheckbox();

        // Инициализация выделения вкладки настроек
        highlightOptionsTab();

        // Загрузка полей сущности при инициализации
        loadEntityFields(entityType);

        // Загрузка маппингов для начального типа сущности
        loadMappingsForType(entityType);

        // Переходим на вкладку с образцом данных для проверки
        setTimeout(function () {
            // Выбираем вкладку "Образец данных" для проверки отображения
            const sampleTab = document.getElementById('sample-tab');
            if (sampleTab) {
                // Проверим, есть ли в sampleData записи
                const sampleRows = document.querySelectorAll('#sample tbody tr');
                console.log(`Найдено ${sampleRows.length} строк с образцами данных`);
            }
        }, 500);
    });

    // Инициализация файла в форме
    function initFileInput() {
        // Получаем файл с предыдущей страницы через localStorage или через сессию
        // В реальном приложении здесь должен быть код, который восстанавливает файл

        // Для демонстрации просто устанавливаем имя файла
        const fileNameElement = document.querySelector('[name="fileName"]');
        if (fileNameElement) {
            const fileName = fileNameElement.value;
            console.log('Имя файла:', fileName);
        }
    }

    // Обработка изменения типа сущности
    function initEntityTypeSelector() {
        const entityTypeSelect = document.getElementById('entityTypeSelect');

        if (entityTypeSelect) {
            entityTypeSelect.addEventListener('change', function () {
                // Обновляем глобальную переменную с типом сущности
                entityType = this.value;
                console.log(`Выбран новый тип сущности: ${entityType}`);

                // Загружаем поля для нового типа сущности
                loadEntityFields(entityType);

                // Загружаем маппинги для нового типа сущности
                loadMappingsForType(entityType);
            });
        }
    }

    // Загрузка полей сущности
    function loadEntityFields(entityType) {
        console.log('Загрузка полей сущности для типа:', entityType);

        if (!entityFieldsMetadata || !entityFieldsMetadata[entityType]) {
            console.error('Метаданные для типа ' + entityType + ' не найдены');
            return;
        }

        // Проверяем, является ли это product_with_related
        if (entityType === 'product_with_related') {
            // Показываем специальную таблицу для связанных сущностей
            showRelatedEntitiesMappingTable();
            return;
        }

        // Получаем поля для данного типа сущности
        const fieldMappings = entityFieldsMetadata[entityType];
        const fields = [];

        // Преобразуем объект маппинга в массив полей
        for (const [displayName, fieldName] of Object.entries(fieldMappings)) {
            fields.push({
                name: fieldName,
                displayName: displayName
            });
        }

        console.log('Поля для типа ' + entityType + ':', fields);

        // Заполняем все селекторы полей
        const fieldSelectors = document.querySelectorAll('.entity-field-selector');
        console.log(`Найдено ${fieldSelectors.length} селекторов полей`);

        fieldSelectors.forEach(selector => {
            // Сохраняем текущее значение
            const currentValue = selector.value;

            // Очищаем селектор
            selector.innerHTML = '';

            // Добавляем опцию "Не импортировать"
            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.text = '-- Не импортировать --';
            selector.appendChild(emptyOption);

            // Добавляем поля сущности
            fields.forEach(field => {
                const option = document.createElement('option');
                option.value = field.name;
                option.text = field.displayName;
                selector.appendChild(option);
            });

            // Восстанавливаем выбранное значение, если оно есть среди новых опций
            if (currentValue) {
                for (let i = 0; i < selector.options.length; i++) {
                    if (selector.options[i].value === currentValue) {
                        selector.selectedIndex = i;
                        break;
                    }
                }
            }
        });
    }

    // Инициализация обработчиков для селекторов схем
    function initMappingSelectors() {
        const mappingCards = document.querySelectorAll('.mapping-card');
        const mappingSelectors = document.querySelectorAll('.mapping-selector');

        console.log(`Инициализация ${mappingCards.length} карточек маппинга и ${mappingSelectors.length} селекторов`);

        // Обработка клика по карточке схемы
        mappingCards.forEach(card => {
            card.addEventListener('click', function () {
                const mappingId = this.dataset.mappingId;
                console.log(`Клик по карточке маппинга ${mappingId}`);

                const radio = document.getElementById('mapping_' + mappingId);

                // Выбираем соответствующий радиобаттон
                if (radio) {
                    radio.checked = true;

                    // Обновляем стили карточек
                    updateMappingCardStyles();

                    // Если выбрана существующая схема, загружаем её данные
                    if (mappingId !== 'new') {
                        loadMappingData(mappingId);

                        // Показываем вкладку параметров как заполненную
                        const optionsTab = document.getElementById('options-tab');
                        if (optionsTab) {
                            optionsTab.classList.add('text-primary');
                            optionsTab.setAttribute('data-filled', 'true');
                        }
                    } else {
                        // Если выбрана "Создать новую схему", предлагаем автоматическое сопоставление
                        suggestFieldMapping();

                        // Сбрасываем параметры импорта
                        resetImportParams();

                        // Снимаем отметку с вкладки параметров
                        const optionsTab = document.getElementById('options-tab');
                        if (optionsTab) {
                            optionsTab.classList.remove('text-primary');
                            optionsTab.removeAttribute('data-filled');
                        }
                    }
                }
            });
        });

        // Обработка изменения радиобаттона
        mappingSelectors.forEach(selector => {
            selector.addEventListener('change', function () {
                const mappingId = this.value;
                console.log(`Выбор маппинга через радиокнопку: ${mappingId}`);

                updateMappingCardStyles();

                if (mappingId !== 'new') {
                    loadMappingData(mappingId);

                    // Показываем вкладку параметров
                    const optionsTab = document.getElementById('options-tab');
                    if (optionsTab) {
                        optionsTab.classList.add('text-primary');
                        optionsTab.setAttribute('data-filled', 'true');
                    }
                } else {
                    // Если выбрана "Создать новую схему", предлагаем автоматическое сопоставление
                    suggestFieldMapping();

                    // Сбрасываем параметры импорта
                    resetImportParams();

                    // Снимаем отметку с вкладки параметров
                    const optionsTab = document.getElementById('options-tab');
                    if (optionsTab) {
                        optionsTab.classList.remove('text-primary');
                        optionsTab.removeAttribute('data-filled');
                    }
                }
            });
        });

        // Обновляем стили при загрузке страницы
        updateMappingCardStyles();
    }

    // Обновление стилей карточек схем
    function updateMappingCardStyles() {
        const mappingCards = document.querySelectorAll('.mapping-card');

        mappingCards.forEach(card => {
            const mappingId = card.dataset.mappingId;
            const radio = document.getElementById('mapping_' + mappingId);

            if (radio && radio.checked) {
                card.classList.add('selected');
            } else {
                card.classList.remove('selected');
            }
        });
    }

    // Загрузка маппингов для типа сущности
    function loadMappingsForType(newEntityType) {
        console.log(`Загрузка маппингов для типа: ${newEntityType}`);

        fetch(`/import/api/mappings/${clientId}/${newEntityType}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Ошибка при получении маппингов: ' + response.status);
                }
                return response.json();
            })
            .then(mappings => {
                console.log(`Получено ${mappings.length} маппингов для типа ${newEntityType}`);

                // Находим контейнер для карточек маппинга
                const mappingsRow = document.querySelector('.row:has(.mapping-card)');
                if (!mappingsRow) {
                    console.error('Контейнер с маппингами не найден');
                    return;
                }

                // Запоминаем карточку "Создать новую схему"
                const createNewCard = document.querySelector('.mapping-card.create-new');
                const createNewCardParent = createNewCard ? createNewCard.closest('.col-md-6') : null;

                // Удаляем все существующие карточки, кроме "Создать новую схему"
                mappingsRow.querySelectorAll('.col-md-6').forEach(col => {
                    const card = col.querySelector('.mapping-card');
                    if (card && !card.classList.contains('create-new')) {
                        col.remove();
                    }
                });

                // Добавляем полученные маппинги
                mappings.forEach(mapping => {
                    const mappingCol = document.createElement('div');
                    mappingCol.className = 'col-md-6 mb-3';
                    mappingCol.innerHTML = `
                    <div class="mapping-card" data-mapping-id="${mapping.id}">
                        <div class="mapping-header">
                            <div class="mapping-title">${mapping.name}</div>
                            <div class="mapping-radio">
                                <input type="radio" id="mapping_${mapping.id}" name="mappingId"
                                       value="${mapping.id}" class="form-check-input mapping-selector"/>
                            </div>
                        </div>
                        <div class="mapping-description">${mapping.description || ''}</div>
                        <div class="mapping-details">
                            <small>Полей: ${mapping.fields_count}</small>
                            <small class="ms-2">
                                <span class="badge ${mapping.client_id == clientId ? 'bg-primary' : 'bg-secondary'}">
                                    ${mapping.client_id == clientId ? 'Персональный' : 'Общий'}
                                </span>
                            </small>
                        </div>
                    </div>
                `;

                    // Вставляем перед "Создать новую схему"
                    if (createNewCardParent) {
                        mappingsRow.insertBefore(mappingCol, createNewCardParent);
                    } else {
                        mappingsRow.appendChild(mappingCol);
                    }
                });

                // Переинициализируем обработчики
                initMappingSelectors();

                // По умолчанию выбираем первый маппинг или "Создать новую схему"
                if (mappings.length > 0) {
                    const firstMappingRadio = document.getElementById(`mapping_${mappings[0].id}`);
                    if (firstMappingRadio) {
                        firstMappingRadio.checked = true;
                        updateMappingCardStyles();
                        loadMappingData(mappings[0].id);
                    }
                } else {
                    const newMappingRadio = document.getElementById('mapping_new');
                    if (newMappingRadio) {
                        newMappingRadio.checked = true;
                        updateMappingCardStyles();
                        suggestFieldMapping();
                    }
                }
            })
            .catch(error => {
                console.error('Ошибка при загрузке маппингов:', error);
            });
    }

    // Загрузка данных схемы сопоставления
    function loadMappingData(mappingId) {
        console.log(`Загрузка данных маппинга ID: ${mappingId}, клиент: ${clientId}, тип: ${entityType}`);

        // Показываем индикатор загрузки
        const mappingTable = document.getElementById('mappingTableContainer');
        if (mappingTable) {
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'loading-indicator';
            loadingIndicator.innerHTML = '<div class="spinner-border text-primary" role="status"><span class="visually-hidden">Загрузка...</span></div>';
            mappingTable.appendChild(loadingIndicator);
        }

        // Запрашиваем данные маппинга
        fetch(`/import/api/mappings/${clientId}/${entityType}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Ошибка при получении маппингов: ' + response.status);
                }
                return response.json();
            })
            .then(mappings => {
                // Находим нужный маппинг по ID
                const selectedMapping = mappings.find(m => m.id == mappingId);

                if (selectedMapping) {
                    console.log('Найден маппинг:', selectedMapping);

                    // Проверяем формат данных маппинга
                    let fieldMapping = null;

                    if (selectedMapping.field_mapping) {
                        // Если поле field_mapping уже является объектом
                        if (typeof selectedMapping.field_mapping === 'object') {
                            fieldMapping = selectedMapping.field_mapping;
                        }
                        // Если field_mapping - строка JSON
                        else if (typeof selectedMapping.field_mapping === 'string') {
                            try {
                                fieldMapping = JSON.parse(selectedMapping.field_mapping);
                            } catch (e) {
                                console.error('Ошибка при разборе JSON field_mapping:', e);
                            }
                        }
                    }

                    // Если есть поле mappings, используем его
                    if (!fieldMapping && selectedMapping.mappings) {
                        fieldMapping = selectedMapping.mappings;
                    }

                    // Если есть поле mapping_data, используем его
                    if (!fieldMapping && selectedMapping.mapping_data) {
                        fieldMapping = selectedMapping.mapping_data;
                    }

                    console.log('Данные маппинга полей после обработки:', fieldMapping);

                    if (fieldMapping) {
                        // Добавим задержку, чтобы убедиться, что все селекторы загружены
                        setTimeout(() => {
                            enhancedFillFieldSelectors(fieldMapping);
                        }, 300);
                    } else {
                        console.warn('Не удалось найти данные маппинга полей в ответе от сервера');
                    }

                    // Заполняем параметры импорта
                    if (selectedMapping.import_params) {
                        fillImportParams(selectedMapping.import_params);
                    }
                } else {
                    console.warn(`Маппинг с ID ${mappingId} не найден среди ${mappings.length} маппингов`);
                }
            })
            .catch(error => {
                console.error('Ошибка при загрузке данных маппинга:', error);
            })
            .finally(() => {
                // Удаляем индикатор загрузки
                const loadingIndicator = document.querySelector('.loading-indicator');
                if (loadingIndicator) {
                    loadingIndicator.remove();
                }
            });
    }

    function enhancedFillFieldSelectors(mapping) {
        console.log('Расширенное заполнение полей маппинга:', mapping);

        if (!mapping || Object.keys(mapping).length === 0) {
            console.warn('Пустые данные маппинга');
            return;
        }

        // Получаем все селекторы полей
        const fieldSelectors = document.querySelectorAll('.entity-field-selector');
        console.log(`Найдено ${fieldSelectors.length} селекторов полей`);

        if (fieldSelectors.length === 0) {
            console.error('Не найдены селекторы полей для заполнения!');
            return;
        }

        let filledCount = 0;

        // Выводим все селекторы для отладки
        fieldSelectors.forEach((selector, index) => {
            const row = selector.closest('tr');
            const sourceCell = row ? row.querySelector('td:first-child') : null;
            const sourceField = sourceCell ? sourceCell.textContent.trim() : `Unknown${index}`;

            console.log(`Селектор #${index}: поле="${sourceField}", options=${selector.options.length}`);
        });

        // Обходим все селекторы и пытаемся заполнить их
        fieldSelectors.forEach(selector => {
            // Получаем строку селектора
            const row = selector.closest('tr');
            if (!row) {
                console.warn('Не удалось найти строку для селектора');
                return;
            }

            // Получаем исходное поле из первой ячейки строки
            const sourceCell = row.querySelector('td:first-child');
            if (!sourceCell) {
                console.warn('Не удалось найти ячейку с исходным полем');
                return;
            }

            const sourceField = sourceCell.textContent.trim();
            console.log(`Обработка селектора для поля "${sourceField}"`);

            // Проверяем все возможные варианты ключей в маппинге
            let targetField = mapping[sourceField]; // Прямое совпадение

            // Если прямого совпадения нет, пробуем найти без учета регистра
            if (!targetField) {
                const lowerSourceField = sourceField.toLowerCase();
                for (const [key, value] of Object.entries(mapping)) {
                    if (key.toLowerCase() === lowerSourceField) {
                        targetField = value;
                        console.log(`Найдено совпадение без учета регистра: ${key} -> ${value}`);
                        break;
                    }
                }
            }

            // Если нашли целевое поле, устанавливаем его в селекторе
            if (targetField) {
                console.log(`Для поля "${sourceField}" найдено значение "${targetField}"`);

                // Выводим список всех опций селектора
                let optionsLog = 'Доступные опции: ';
                for (let i = 0; i < selector.options.length; i++) {
                    optionsLog += `[${i}: ${selector.options[i].value}] `;
                }
                console.log(optionsLog);

                // Устанавливаем значение селектора
                let found = false;
                for (let i = 0; i < selector.options.length; i++) {
                    if (selector.options[i].value === targetField) {
                        console.log(`Устанавливаем индекс ${i} для поля "${sourceField}"`);
                        selector.selectedIndex = i;
                        found = true;
                        filledCount++;
                        break;
                    }
                }

                if (!found) {
                    console.warn(`Значение "${targetField}" не найдено в опциях селектора для поля "${sourceField}"`);
                }
            } else {
                console.log(`Для поля "${sourceField}" не найдено соответствие в маппинге`);
            }
        });

        console.log(`Заполнено ${filledCount} из ${fieldSelectors.length} селекторов полей`);
    }

    // Заполнение селекторов полей на основе маппинга
    function fillFieldSelectors(mapping) {
        console.log('Заполнение селекторов полей с маппингом:', mapping);

        if (!mapping) return;

        // Получаем все селекторы полей
        const fieldSelectors = document.querySelectorAll('.entity-field-selector');
        let filledCount = 0;

        fieldSelectors.forEach(selector => {
            // Получаем имя поля из файла (из ячейки в той же строке)
            const sourceField = selector.closest('tr').querySelector('td:first-child').textContent.trim();

            // Проверяем наличие поля в маппинге
            let targetField = mapping[sourceField];

            // Если прямое сопоставление не найдено, ищем без учета регистра
            if (!targetField) {
                for (const [key, value] of Object.entries(mapping)) {
                    if (key.toLowerCase() === sourceField.toLowerCase()) {
                        targetField = value;
                        break;
                    }
                }
            }

            if (targetField) {
                console.log(`Для поля "${sourceField}" найдено сопоставление: "${targetField}"`);

                // Устанавливаем значение в селекторе
                for (let i = 0; i < selector.options.length; i++) {
                    if (selector.options[i].value === targetField) {
                        selector.selectedIndex = i;
                        filledCount++;
                        break;
                    }
                }
            }
        });

        console.log(`Заполнено ${filledCount} из ${fieldSelectors.length} селекторов полей`);
    }

    // Заполнение параметров импорта
    function fillImportParams(params) {
        console.log('Заполнение параметров импорта:', params);

        if (!params) return;

        // Заполняем селекторы
        if (params.processingStrategy) {
            setSelectValue('processingStrategy', params.processingStrategy);
        }

        if (params.batchSize) {
            setSelectValue('batchSize', params.batchSize);
        }

        if (params.errorHandling) {
            setSelectValue('errorHandling', params.errorHandling);
        }

        if (params.duplicateHandling) {
            setSelectValue('duplicateHandling', params.duplicateHandling);
        }

        // Заполняем чекбоксы
        setCheckboxValue('validateData', params.validateData);
        setCheckboxValue('trimWhitespace', params.trimWhitespace);
        setCheckboxValue('generateReport', params.generateReport);
        setCheckboxValue('notifyOnComplete', params.notifyOnComplete);
    }

    // Сбрасывает параметры импорта к значениям по умолчанию
    function resetImportParams() {
        // Сбрасываем селекторы к первым опциям
        document.getElementById('processingStrategy').selectedIndex = 0;
        document.getElementById('batchSize').selectedIndex = 1; // 500 записей по умолчанию
        document.getElementById('errorHandling').selectedIndex = 1; // Пропускать ошибки по умолчанию
        document.getElementById('duplicateHandling').selectedIndex = 0; // Пропускать дубликаты по умолчанию

        // Устанавливаем чекбоксы в значения по умолчанию
        document.getElementById('validateData').checked = true;
        document.getElementById('trimWhitespace').checked = true;
        document.getElementById('generateReport').checked = true;
        document.getElementById('notifyOnComplete').checked = true;
    }

    // Вспомогательная функция для установки значения селектора
    function setSelectValue(id, value) {
        const select = document.getElementById(id);
        if (!select) return;

        for (let i = 0; i < select.options.length; i++) {
            if (select.options[i].value === String(value)) {
                select.selectedIndex = i;
                break;
            }
        }
    }

    // Вспомогательная функция для установки значения чекбокса
    function setCheckboxValue(id, value) {
        const checkbox = document.getElementById(id);
        if (!checkbox) return;

        checkbox.checked = value === true || value === 'true' || value === '1';
    }

    // Инициализация флажка сохранения схемы
    function initSaveMappingCheckbox() {
        const saveMapping = document.getElementById('saveMapping');
        const saveMappingOptions = document.getElementById('saveMappingOptions');

        if (saveMapping && saveMappingOptions) {
            saveMapping.addEventListener('change', function () {
                saveMappingOptions.style.display = this.checked ? 'block' : 'none';
            });
        }
    }

    // Выделяет вкладку настроек импорта
    function highlightOptionsTab() {
        // Добавляем стиль для отображения заполненных параметров
        const style = document.createElement('style');
        style.textContent = `
        .nav-link[data-filled="true"] {
            font-weight: bold;
            position: relative;
        }
        .nav-link[data-filled="true"]::after {
            content: '✓';
            position: absolute;
            top: 0;
            right: 5px;
            color: #28a745;
            font-size: 14px;
        }
    `;
        document.head.appendChild(style);
    }

    // Предложение автоматического сопоставления полей
    function suggestFieldMapping() {
        const fieldSelectors = document.querySelectorAll('.entity-field-selector');
        console.log(`Попытка автоматического сопоставления для ${fieldSelectors.length} полей`);

        fieldSelectors.forEach(selector => {
            // Получаем имя поля из файла
            const sourceField = selector.closest('tr').querySelector('td:first-child').textContent.trim();
            const sourceFieldLower = sourceField.toLowerCase();

            // Очищаем текущее значение
            selector.selectedIndex = 0;

            // Проверяем каждую опцию селектора для поиска совпадения
            for (let i = 1; i < selector.options.length; i++) {
                const option = selector.options[i];
                const optionText = option.text.toLowerCase();
                const optionValue = option.value.toLowerCase();

                // Точное совпадение
                if (optionText === sourceFieldLower || optionValue === sourceFieldLower) {
                    selector.selectedIndex = i;
                    console.log(`Точное совпадение для "${sourceField}": ${option.text}`);
                    break;
                }

                // Частичное совпадение
                if (optionText.includes(sourceFieldLower) || sourceFieldLower.includes(optionText) ||
                    optionValue.includes(sourceFieldLower) || sourceFieldLower.includes(optionValue)) {
                    selector.selectedIndex = i;
                    console.log(`Частичное совпадение для "${sourceField}": ${option.text}`);
                    break;
                }
            }
        });
    }

    // Функция для отображения группированной таблицы маппинга
    function showRelatedEntitiesMappingTable() {
        console.log('Отображение таблицы для связанных сущностей');

        const mappingTableBody = document.getElementById('mappingTableBody');
        const headers = Array.from(mappingTableBody.querySelectorAll('tr td:first-child')).map(td => td.textContent.trim());

        // Получаем метаданные для связанных сущностей
        const productWithRelated = entityFieldsMetadata['product_with_related'];

        if (!productWithRelated) {
            console.error('Метаданные для product_with_related не найдены!');
            return;
        }

        // Создаем новый HTML для таблицы маппинга
        let newRows = '';
        headers.forEach(header => {
            newRows += `
        <tr>
            <td class="source-header">${header}</td>
            <td>
                <select name="mapping[${header}]" class="form-select entity-field-selector">
                    <option value="">-- Не импортировать --</option>`;

            // Группа "Товар"
            newRows += `<optgroup label="Товар">`;
            // Получаем поля для товара из метаданных
            const productFields = entityFieldsMetadata['product'] || {};
            for (const [displayName, fieldName] of Object.entries(productFields)) {
                newRows += `<option value="${fieldName}">${displayName}</option>`;
            }
            newRows += `</optgroup>`;

            // Группа "Регион"
            newRows += `<optgroup label="Регион">`;
            const regionFields = entityFieldsMetadata['regiondata'] || {};
            for (const [displayName, fieldName] of Object.entries(regionFields)) {
                newRows += `<option value="${fieldName}">${displayName}</option>`;
            }
            newRows += `</optgroup>`;

            // Группа "Конкурент"
            newRows += `<optgroup label="Конкурент">`;
            const competitorFields = entityFieldsMetadata['competitordata'] || {};
            for (const [displayName, fieldName] of Object.entries(competitorFields)) {
                newRows += `<option value="${fieldName}">${displayName}</option>`;
            }
            newRows += `</optgroup>`;

            newRows += `</select>
            </td>
        </tr>`;
        });

        mappingTableBody.innerHTML = newRows;

        // Добавляем информационное сообщение
        const mappingInfo = document.createElement('div');
        mappingInfo.className = 'alert alert-info mt-3';
        mappingInfo.innerHTML = `
        <i class="fas fa-info-circle me-2"></i>
        <strong>Импорт связанных сущностей:</strong> Для каждого поля из файла выберите соответствующее поле сущности.
        Поля могут относиться к разным типам сущностей (Товар, Регион, Конкурент).
        Система автоматически создаст и свяжет все необходимые сущности.
    `;

        const existingInfo = document.querySelector('#mappingTableContainer .alert');
        if (existingInfo) {
            existingInfo.remove();
        }

        document.getElementById('mappingTableContainer').insertBefore(mappingInfo, document.querySelector('#mappingTableContainer .table-scroll'));

        // Предлагаем автоматическое сопоставление полей
        autoSuggestRelatedFieldMappings(headers);
    }

    // Автоматическое сопоставление полей для связанных сущностей
    function autoSuggestRelatedFieldMappings(headers) {
        console.log('Автоматическое сопоставление полей для связанных сущностей:', headers);

        // Создаем обратный маппинг (имя поля -> имя поля сущности)
        const reverseMapping = {};

        // Добавляем маппинги из всех типов сущностей
        ['product', 'regiondata', 'competitordata'].forEach(entityType => {
            const mappings = entityFieldsMetadata[entityType];
            if (mappings) {
                Object.entries(mappings).forEach(([displayName, fieldName]) => {
                    reverseMapping[displayName.toLowerCase()] = fieldName;
                });
            }
        });

        // Применяем сопоставление
        headers.forEach(header => {
            const selector = document.querySelector(`select[name="mapping[${header}]"]`);
            if (!selector) return;

            const headerLower = header.toLowerCase();

            // Проверяем точное совпадение
            if (reverseMapping[headerLower]) {
                for (let i = 0; i < selector.options.length; i++) {
                    if (selector.options[i].value === reverseMapping[headerLower]) {
                        selector.selectedIndex = i;
                        break;
                    }
                }
                return;
            }

            // Проверяем частичное совпадение
            for (const [key, value] of Object.entries(reverseMapping)) {
                if (key.includes(headerLower) || headerLower.includes(key)) {
                    for (let i = 0; i < selector.options.length; i++) {
                        if (selector.options[i].value === value) {
                            selector.selectedIndex = i;
                            break;
                        }
                    }
                    return;
                }
            }
        });
    }

    // Проверка настройки отображения образца данных
    setTimeout(function () {
        const sampleTab = document.getElementById('sample-tab');
        if (sampleTab) {
            const sampleTable = document.querySelector('#sample .table');
            if (sampleTable) {
                const rows = sampleTable.querySelectorAll('tbody tr');
                console.log(`Найдено ${rows.length} строк в таблице образца данных`);

                if (rows.length === 0) {
                    console.warn('Таблица образца данных пуста!');

                    // Проверяем, есть ли данные в анализе
                    const analysisData = /*[[${analysis.sampleData}]]*/ [];
                    console.log('Данные образца из анализа:', analysisData);

                    // Если есть проблема с таблицей, добавляем сообщение
                    const container = document.querySelector('#sample .card-body');
                    if (container) {
                        container.insertAdjacentHTML('beforeend', `
                        <div class="alert alert-warning mt-3">
                            <i class="fas fa-exclamation-triangle me-2"></i>
                            <strong>Внимание!</strong> Обнаружена проблема с отображением образца данных.
                            Рекомендуется проверить формат данных в анализе.
                        </div>
                    `);
                    }
                }
            }
        }
    }, 1000);
</script>
</body>
</html>