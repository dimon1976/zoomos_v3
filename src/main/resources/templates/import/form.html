<!DOCTYPE html>
<html lang="ru" xmlns:th="http://www.thymeleaf.org"
      th:replace="~{layout/main :: html(
        'Импорт данных - Обработка файлов',
        ~{::section},
        ~{::script},
        ~{::style},
        ${client.name + ' - Импорт данных'},
        ~{::.page-actions}
      )}">
<head>
    <title>Импорт данных - Обработка файлов</title>
    <style>
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            transition: all 0.3s;
            background-color: #f8f9fa;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #0d6efd;
            background-color: #f1f8ff;
        }

        .upload-area.dragging {
            border-color: #0d6efd;
            background-color: #e8f0fe;
        }

        .upload-icon {
            font-size: 48px;
            color: #0d6efd;
            margin-bottom: 20px;
        }

        .entity-type-card {
            cursor: pointer;
            transition: all 0.2s;
            height: 100%;
        }

        .entity-type-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .entity-type-card.selected {
            border-color: #0d6efd;
            background-color: #f0f7ff;
        }

        .progress-container {
            margin-top: 20px;
        }

        #filePreview {
            display: none;
            margin-top: 20px;
        }

        .preview-table {
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
<!-- Действия страницы -->
<div class="page-actions">
    <a th:href="@{/clients/{id}(id=${client.id})}" class="btn btn-secondary me-2">
        <i class="fas fa-arrow-left me-1"></i>К клиенту
    </a>
    <a th:href="@{/clients/{id}/operations(id=${client.id})}" class="btn btn-primary me-2">
        <i class="fas fa-history me-1"></i>Операции
    </a>
    <a th:href="@{/clients/{id}/export(id=${client.id})}" class="btn btn-success">
        <i class="fas fa-file-export me-1"></i>Экспорт
    </a>
</div>

<section>
    <!-- Информация о клиенте -->
    <div class="card mb-4">
        <div class="card-header">
            <h5 class="mb-0">Импорт данных для клиента</h5>
        </div>
        <div class="card-body">
            <p>Загрузите файл CSV или Excel для импорта данных в систему.</p>

            <form id="importForm" th:action="@{/clients/{id}/import(id=${client.id})}" method="post"
                  enctype="multipart/form-data">
                <!-- Загрузка файла -->
                <div class="mb-4">
                    <h5>1. Загрузите файл</h5>
                    <div class="upload-area mt-2" id="dropArea">
                        <input type="file" name="file" id="fileInput" accept=".csv,.xlsx,.xls" class="d-none" required>
                        <div class="upload-icon">
                            <i class="fas fa-cloud-upload-alt"></i>
                        </div>
                        <h5>Перетащите файл сюда или кликните для выбора</h5>
                        <p class="text-muted">Поддерживаемые форматы: CSV, Excel (.xlsx, .xls)</p>
                    </div>

                    <!-- Предпросмотр файла -->
                    <div id="filePreview" class="card mt-3">
                        <div class="card-header">
                            <div class="d-flex justify-content-between align-items-center">
                                <h5 class="mb-0">Предпросмотр файла</h5>
                                <button type="button" id="removeFile" class="btn btn-sm btn-outline-danger">
                                    <i class="fas fa-times me-1"></i>Удалить
                                </button>
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <strong>Имя файла:</strong> <span id="fileName"></span>
                            </div>
                            <div class="mb-3">
                                <strong>Размер:</strong> <span id="fileSize"></span>
                            </div>
                            <div class="mb-3">
                                <strong>Тип:</strong> <span id="fileType"></span>
                            </div>
                            <div class="mb-3">
                                <h6>Обнаруженные столбцы:</h6>
                                <div class="preview-table">
                                    <table class="table table-sm table-bordered" id="previewTable">
                                        <thead>
                                        <tr id="headerRow"></tr>
                                        </thead>
                                        <tbody id="previewBody"></tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Включение компонента выбора полей -->
                <div th:replace="components/field-selection :: fieldSelection(${client.id}, 'import')"></div>

                <!-- Параметры импорта - убрали класс d-none, чтобы блок всегда был виден -->
                <div id="importOptions" class="mb-4">
                    <h5>2. Настройте параметры импорта</h5>
                    <div class="card mt-2">
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    <!-- Поле скрыто, так как значение теперь выбирается в компоненте field-selection -->
                                    <input type="hidden" id="mappingId" name="mappingId" value="">
                                    <label for="strategyId" class="form-label">Стратегия импорта</label>
                                    <select class="form-select" id="strategyId" name="strategyId">
                                        <option value="">По умолчанию</option>
                                        <!-- Опции будут добавлены динамически -->
                                    </select>
                                </div>
                            </div>

                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    <label for="errorHandling" class="form-label">Обработка ошибок</label>
                                    <select class="form-select" id="errorHandling" name="params[errorHandling]">
                                        <option value="continue">Продолжать при ошибках</option>
                                        <option value="stop">Остановить при первой ошибке</option>
                                        <option value="report">Собирать отчет об ошибках</option>
                                    </select>
                                </div>
                                <div class="col-md-6 mb-3">
                                    <label for="duplicateHandling" class="form-label">Обработка дубликатов</label>
                                    <select class="form-select" id="duplicateHandling" name="params[duplicateHandling]">
                                        <option value="skip">Пропускать дубликаты</option>
                                        <option value="update">Обновлять существующие записи</option>
                                        <option value="error">Выдавать ошибку при дубликатах</option>
                                    </select>
                                </div>
                            </div>

                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="validateData"
                                               name="params[validateData]" value="true" checked>
                                        <label class="form-check-label" for="validateData">
                                            Валидировать данные перед импортом
                                        </label>
                                    </div>
                                </div>
                                <div class="col-md-6 mb-3">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="trimWhitespace"
                                               name="params[trimWhitespace]" value="true" checked>
                                        <label class="form-check-label" for="trimWhitespace">
                                            Удалять лишние пробелы
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Кнопки действий -->
                <div class="mt-4 text-center">
                    <button type="submit" id="startImportBtn" class="btn btn-primary btn-lg px-4" disabled>
                        <i class="fas fa-file-import me-1"></i>Начать импорт
                    </button>
                    <a th:href="@{/clients/{id}(id=${client.id})}" class="btn btn-outline-secondary btn-lg px-4 ms-2">
                        <i class="fas fa-times me-1"></i>Отмена
                    </a>
                </div>


                <!-- Прогресс импорта -->
                <div id="importProgress" class="progress-container d-none">
                    <div class="card">
                        <div class="card-body">
                            <h5 class="mb-3">Прогресс импорта</h5>
                            <div class="progress mb-3" style="height: 25px;">
                                <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated"
                                     role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0"
                                     aria-valuemax="100">0%
                                </div>
                            </div>
                            <div id="importStatus">Подготовка к импорту...</div>
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </div>
</section>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        console.log('DOMContentLoaded: Инициализация скрипта импорта');

        // Получаем ссылки на основные DOM-элементы
        const importForm = document.getElementById('importForm');
        const fileInput = document.getElementById('fileInput');
        const startImportBtn = document.getElementById('startImportBtn');
        const dropArea = document.getElementById('dropArea');
        const filePreview = document.getElementById('filePreview');
        const removeFileBtn = document.getElementById('removeFile');
        const progressContainer = document.getElementById('importProgress');

        console.log('Форма импорта:', importForm);
        console.log('Кнопка импорта:', startImportBtn);

        // Синхронизируем значение mappingId с компонентом выбора полей
        const selectedMappingIdField = document.getElementById('selectedMappingId');
        const mappingIdField = document.getElementById('mappingId');

        // Если поле selectedMappingId существует, устанавливаем обработчик изменений
        if (selectedMappingIdField) {
            console.log('Найдено поле selectedMappingId, настраиваем синхронизацию');
            // Начальная синхронизация значений
            mappingIdField.value = selectedMappingIdField.value;

            // Следим за изменениями в компоненте выбора полей
            const observer = new MutationObserver(function (mutations) {
                mutations.forEach(function (mutation) {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'value') {
                        mappingIdField.value = selectedMappingIdField.value;
                        console.log('Синхронизировано значение mappingId:', mappingIdField.value);
                    }
                });
            });

            observer.observe(selectedMappingIdField, {attributes: true});
        } else {
            console.warn('Поле selectedMappingId не найдено');
        }

        // Обработка клика по области загрузки
        dropArea.addEventListener('click', () => {
            fileInput.click();
        });

        // Обработка перетаскивания файла
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });

        function highlight() {
            dropArea.classList.add('dragging');
        }

        function unhighlight() {
            dropArea.classList.remove('dragging');
        }

        // Обработка выбора файла
        fileInput.addEventListener('change', handleFileSelect, false);
        dropArea.addEventListener('drop', handleFileDrop, false);

        function handleFileDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                fileInput.files = files;
                handleFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const files = e.target.files;

            if (files.length > 0) {
                handleFile(files[0]);
            }
        }

        function handleFile(file) {
            console.log('Обработка файла:', file.name);
            // Показываем превью файла
            filePreview.style.display = 'block';
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = formatFileSize(file.size);
            document.getElementById('fileType').textContent = file.type || getFileExtension(file.name);

            // Активируем кнопку импорта
            startImportBtn.disabled = false;
            console.log('Кнопка импорта активирована');

            // Анализируем файл
            analyzeFile(file);
        }

        // Удаление файла
        removeFileBtn.addEventListener('click', function () {
            fileInput.value = '';
            filePreview.style.display = 'none';
            startImportBtn.disabled = true;
            console.log('Файл удален, кнопка импорта деактивирована');
        });

        // Обработчик отправки формы
        importForm.addEventListener('submit', function (e) {
            console.log('Попытка отправки формы');

            // Проверяем наличие файла
            if (!fileInput.files || fileInput.files.length === 0) {
                e.preventDefault();
                alert('Пожалуйста, выберите файл для импорта');
                console.warn('Отправка формы отменена: файл не выбран');
                return false;
            }

            // Показываем прогресс импорта
            progressContainer.classList.remove('d-none');

            // Блокируем кнопку импорта
            startImportBtn.disabled = true;

            // Обновляем прогресс-бар
            const progressBar = document.getElementById('progressBar');
            const statusText = document.getElementById('importStatus');
            progressBar.style.width = '30%';
            progressBar.setAttribute('aria-valuenow', 30);
            progressBar.textContent = '30%';
            statusText.textContent = 'Отправка файла...';

            // Логируем данные формы перед отправкой
            console.log('Отправка формы с параметрами:');
            const formData = new FormData(this);
            for (let [key, value] of formData.entries()) {
                console.log(`${key}: ${value}`);
            }

            // Продолжаем стандартную отправку формы
            console.log('Форма отправляется на сервер');
            return true;
        });

        // Функция для обновления списка доступных маппингов
        function updateMappingOptions(mappings) {
            console.log('Обновление доступных маппингов:', mappings);
            const mappingSelect = document.getElementById('mappingSelect');

            // Если элемент не найден в этой странице, проверяем alternative ID
            if (!mappingSelect) {
                console.warn('Элемент с ID "mappingSelect" не найден, проверяем альтернативные ID');

                // Пробуем найти по альтернативному ID
                const altSelect = document.getElementById('mappingId');
                if (altSelect) {
                    console.log('Найден альтернативный элемент для маппингов:', altSelect.id);
                    updateMappingOptionsForElement(altSelect, mappings);
                } else {
                    console.error('Не найдены элементы для отображения маппингов');
                }
                return;
            }

            updateMappingOptionsForElement(mappingSelect, mappings);
        }

        // Вспомогательная функция обновления элемента выбора маппингов
        function updateMappingOptionsForElement(selectElement, mappings) {
            // Очищаем текущие опции
            selectElement.innerHTML = '<option value="">Автоматическое</option>';

            // Добавляем доступные маппинги
            if (mappings && mappings.length > 0) {
                mappings.forEach(mapping => {
                    const option = document.createElement('option');
                    option.value = mapping.id;
                    option.textContent = mapping.name + (mapping.composite ? ' (составной)' : '');
                    selectElement.appendChild(option);
                });
                console.log(`Добавлено ${mappings.length} маппингов в элемент ${selectElement.id}`);
            } else {
                console.log('Нет доступных маппингов для добавления');
            }
        }

        // Функции для форматирования и анализа файла
        function formatFileSize(size) {
            const kb = 1024;
            const mb = kb * 1024;

            if (size < kb) {
                return size + ' B';
            } else if (size < mb) {
                return (size / kb).toFixed(2) + ' KB';
            } else {
                return (size / mb).toFixed(2) + ' MB';
            }
        }

        function getFileExtension(filename) {
            return filename.slice((filename.lastIndexOf('.') - 1 >>> 0) + 2);
        }

        function analyzeFile(file) {
            console.log('Начало анализа файла:', file.name);

            // Очищаем таблицу предпросмотра
            const headerRow = document.getElementById('headerRow');
            const previewBody = document.getElementById('previewBody');

            if (!headerRow || !previewBody) {
                console.error('Не найдены элементы для таблицы предпросмотра');
                return;
            }

            headerRow.innerHTML = '';
            previewBody.innerHTML = '';

            // Показываем индикатор загрузки
            headerRow.innerHTML = '<th class="text-center" colspan="10"><div class="spinner-border spinner-border-sm text-primary" role="status"><span class="visually-hidden">Загрузка...</span></div> Анализ файла...</th>';

            // Получаем текущий тип сущности и флаг составной сущности
            const entityType = document.getElementById('selectedEntityType')?.value || 'product';
            const isComposite = document.getElementById('isComposite')?.value === 'true';

            // Извлекаем ID клиента из URL
            const pathParts = window.location.pathname.split('/');
            const clientId = pathParts[2];

            console.log('Параметры анализа файла:', {entityType, isComposite, clientId});

            // Создаем форму для отправки файла
            const formData = new FormData();
            formData.append('file', file);
            formData.append('analysisEntityType', entityType);
            formData.append('composite', isComposite);

            // Отправляем файл на сервер для анализа
            const analyzeUrl = `/clients/${clientId}/import/analyze`;
            console.log('Отправка запроса на анализ файла:', analyzeUrl);

            fetch(analyzeUrl, {
                method: 'POST',
                body: formData
            })
                .then(response => {
                    console.log('Получен ответ от сервера:', response.status);
                    if (!response.ok) {
                        throw new Error(`Ошибка HTTP: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Данные анализа файла:', data);

                    // Очищаем строки таблицы
                    headerRow.innerHTML = '';
                    previewBody.innerHTML = '';

                    // Заполняем заголовки, если они есть
                    if (data.headers && data.headers.length > 0) {
                        data.headers.forEach(header => {
                            const th = document.createElement('th');
                            th.textContent = header;
                            headerRow.appendChild(th);
                        });
                    }

                    // Заполняем предпросмотр данных первыми 10 строками, если они есть
                    if (data.sampleData && data.sampleData.length > 0) {
                        // data.sampleData - это массив объектов, а не двумерный массив
                        data.sampleData.forEach(rowObject => {
                            const tr = document.createElement('tr');

                            // Для каждого заголовка получаем соответствующее значение
                            if (data.headers && data.headers.length > 0) {
                                data.headers.forEach(header => {
                                    const td = document.createElement('td');
                                    // Получаем значение по ключу заголовка, если оно существует
                                    const cellValue = rowObject[header] !== undefined ? rowObject[header] : '';
                                    td.textContent = cellValue;
                                    tr.appendChild(td);
                                });
                            } else {
                                // Если заголовки не определены, выводим все значения объекта
                                Object.values(rowObject).forEach(value => {
                                    const td = document.createElement('td');
                                    td.textContent = value !== null ? value : '';
                                    tr.appendChild(td);
                                });
                            }

                            previewBody.appendChild(tr);
                        });

                        // Сообщаем, сколько всего строк в файле, если их больше, чем мы показываем
                        const totalRows = data.totalRows || data.sampleData.length;
                        if (totalRows > data.sampleData.length) {
                            const tr = document.createElement('tr');
                            const td = document.createElement('td');
                            td.colSpan = data.headers ? data.headers.length : Object.keys(data.sampleData[0]).length;
                            td.className = 'text-center text-muted';
                            td.textContent = `...и еще ${totalRows - data.sampleData.length} строк`;
                            tr.appendChild(td);
                            previewBody.appendChild(tr);
                        }
                    }

                    // Обновляем доступные маппинги
                    if (data.availableMappings) {
                        updateMappingOptions(data.availableMappings);
                    }

                    // Сохраняем заголовки и данные для использования при создании маппинга
                    window.fileHeaders = data.headers || [];
                    window.fieldsMetadata = data.fieldsMetadata;

                    // Диспатчим событие для компонента field-selection
                    const event = new CustomEvent('fileAnalyzed', {
                        detail: {
                            headers: data.headers || [],
                            metadata: data.fieldsMetadata
                        }
                    });
                    document.dispatchEvent(event);
                    console.log('Событие fileAnalyzed отправлено');

                    // Если нет данных для предпросмотра
                    if ((!data.headers || data.headers.length === 0) &&
                        (!data.sampleData || data.sampleData.length === 0)) {
                        const tr = document.createElement('tr');
                        const td = document.createElement('td');
                        td.colSpan = 5;
                        td.className = 'text-center text-muted py-3';
                        td.textContent = 'Не удалось прочитать данные из файла или файл пуст';
                        tr.appendChild(td);
                        previewBody.appendChild(tr);
                    }
                })
                .catch(error => {
                    console.error('Ошибка при анализе файла:', error);
                    headerRow.innerHTML = '';
                    previewBody.innerHTML = '';

                    const tr = document.createElement('tr');
                    const td = document.createElement('td');
                    td.colSpan = 5;
                    td.className = 'text-center text-danger py-3';
                    td.textContent = 'Ошибка при анализе файла: ' + error.message;
                    tr.appendChild(td);
                    previewBody.appendChild(tr);
                });
        }

        // Активируем кнопку "Начать импорт" если файл уже был выбран при загрузке страницы
        if (fileInput.files && fileInput.files.length > 0) {
            console.log('Файл уже выбран при загрузке страницы, активируем кнопку импорта');
            startImportBtn.disabled = false;
        }
        // Добавьте этот код в конец вашего скрипта, перед закрывающей скобкой функции DOMContentLoaded
// Функция для глубокой отладки формы и её отправки

        function setupDebugMonitoring() {
            console.log('=== НАСТРОЙКА ОТЛАДОЧНОГО МОНИТОРИНГА ===');

            // 1. Добавляем функцию отладки для проверки состояния формы
            window.debugFormState = function () {
                const form = document.getElementById('importForm');
                if (!form) return console.error('Форма не найдена!');

                console.log('=== СОСТОЯНИЕ ФОРМЫ ===');
                console.log('Действие формы:', form.action);
                console.log('Метод формы:', form.method);
                console.log('Формат данных:', form.enctype);

                // Проверяем все поля формы
                console.log('=== ПОЛЯ ФОРМЫ ===');

                // Собираем все input, select и textarea элементы внутри формы
                const formElements = form.querySelectorAll('input, select, textarea');
                console.log(`Найдено ${formElements.length} полей в форме`);

                formElements.forEach(el => {
                    // Не логируем файловые поля, так как их значения не могут быть преобразованы в строку
                    let value = el.type === 'file' ? `Файл: ${el.files && el.files[0] ? el.files[0].name : 'не выбран'}` : el.value;

                    console.log(`${el.tagName} #${el.id || 'без-id'} name="${el.name || 'без-имени'}" type="${el.type || 'стандартный'}" value="${value}" disabled=${el.disabled}`);
                });

                // Проверка кнопки импорта
                const importBtn = document.getElementById('startImportBtn');
                if (importBtn) {
                    console.log('=== КНОПКА ИМПОРТА ===');
                    console.log('Тип:', importBtn.type);
                    console.log('Отключена:', importBtn.disabled);
                    console.log('Текст:', importBtn.textContent.trim());
                    console.log('Класс:', importBtn.className);
                    console.log('Родитель:', importBtn.parentElement.tagName);
                }

                // Если используем второй вариант с кнопкой manualSubmitBtn
                const manualBtn = document.getElementById('manualSubmitBtn');
                if (manualBtn) {
                    console.log('=== РУЧНАЯ КНОПКА ИМПОРТА ===');
                    console.log('Тип:', manualBtn.type);
                    console.log('Отключена:', manualBtn.disabled);
                    console.log('Текст:', manualBtn.textContent.trim());
                }

                // Создаем FormData для проверки того, что действительно будет отправлено
                const formData = new FormData(form);
                console.log('=== ДАННЫЕ ДЛЯ ОТПРАВКИ (FormData) ===');
                for (let [key, value] of formData.entries()) {
                    // Для файлов показываем имя файла, а не объект File
                    if (value instanceof File) {
                        console.log(`${key}: Файл "${value.name}" (${value.size} байт)`);
                    } else {
                        console.log(`${key}: ${value}`);
                    }
                }
            };

            // 2. Мониторинг изменения состояния кнопки импорта
            const importBtn = document.getElementById('startImportBtn');
            if (importBtn) {
                // Создаем обертку вокруг свойства disabled
                const originalSetter = Object.getOwnPropertyDescriptor(HTMLButtonElement.prototype, 'disabled').set;

                Object.defineProperty(importBtn, 'disabled', {
                    set: function (value) {
                        console.log(`=== ИЗМЕНЕНИЕ СОСТОЯНИЯ КНОПКИ: ${value ? 'отключена' : 'активирована'} ===`);
                        console.trace('Стек вызовов изменения кнопки');
                        originalSetter.call(this, value);
                    }
                });
            }

            // 3. Мониторинг отправки формы
            const form = document.getElementById('importForm');
            if (form) {
                form.addEventListener('submit', function (e) {
                    console.log('=== СОБЫТИЕ ОТПРАВКИ ФОРМЫ ===');
                    console.log('Время:', new Date().toISOString());
                    console.log('Состояние кнопки импорта:', importBtn ? `отключена: ${importBtn.disabled}` : 'кнопка не найдена');

                    // Проверяем состояние формы перед отправкой
                    window.debugFormState();

                    // Не блокируем отправку, это только для отладки
                    console.log('Форма будет отправлена...');
                }, false);
            }

            // 4. Добавляем кнопку отладки в интерфейс
            const debugButton = document.createElement('button');
            debugButton.type = 'button';
            debugButton.className = 'btn btn-sm btn-outline-info mt-2';
            debugButton.textContent = 'Отладка формы';
            debugButton.onclick = window.debugFormState;

            // Добавляем кнопку после контейнера importOptions
            const importOptions = document.getElementById('importOptions');
            if (importOptions && importOptions.parentNode) {
                importOptions.parentNode.insertBefore(debugButton, importOptions.nextSibling);
            }

            console.log('Отладочный мониторинг настроен, нажмите кнопку "Отладка формы" для проверки состояния');

            // 5. Добавляем прямой обработчик клика на кнопку импорта
            const submitButton = document.getElementById('startImportBtn');
            if (submitButton) {
                console.log('Установка прямого обработчика клика на кнопку импорта');

                // Добавляем прямой обработчик клика
                submitButton.addEventListener('click', function (event) {
                    console.log('=== ПРЯМОЙ КЛИК ПО КНОПКЕ ИМПОРТА ===');
                    console.log('Время:', new Date().toISOString());
                    console.log('Кнопка отключена?', this.disabled);

                    // Проверка формы
                    const form = document.getElementById('importForm');
                    if (!form) {
                        console.error('Форма не найдена!');
                        return;
                    }

                    // Проверка файла
                    const fileInput = document.getElementById('fileInput');
                    if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
                        alert('Пожалуйста, выберите файл для импорта');
                        event.preventDefault();
                        return;
                    }

                    // Проверяем состояние формы перед отправкой
                    window.debugFormState();

                    console.log('Форма готова к отправке! Нажимаем submit() напрямую');


                    console.log('Форма готова к отправке! Считываем фактические параметры импорта');

// Определяем параметры, которые нужно собрать и их селекторы
                    const paramConfig = [
                        {
                            name: 'params[errorHandling]',
                            selector: '#errorHandling',
                            defaultValue: 'continue',
                            type: 'select'
                        },
                        {
                            name: 'params[duplicateHandling]',
                            selector: '#duplicateHandling',
                            defaultValue: 'update',
                            type: 'select'
                        },
                        {
                            name: 'params[validateData]',
                            selector: '#validateData',
                            defaultValue: 'true',
                            type: 'checkbox'
                        },
                        {
                            name: 'params[trimWhitespace]',
                            selector: '#trimWhitespace',
                            defaultValue: 'true',
                            type: 'checkbox'
                        }
                    ];

// Собираем фактические значения параметров из формы
                    paramConfig.forEach(param => {
                        // Находим элемент в форме
                        const element = document.querySelector(param.selector);

                        // Проверяем, существует ли элемент
                        if (element) {
                            // Получаем значение в зависимости от типа элемента
                            let value;
                            if (param.type === 'checkbox') {
                                value = element.checked ? element.value || 'true' : 'false';
                            } else if (param.type === 'select') {
                                value = element.value;
                            } else {
                                value = element.value;
                            }

                            console.log(`Найден элемент ${param.name}: ${value}`);

                            // Проверяем, существует ли уже поле с таким именем
                            let existingField = form.querySelector(`input[name="${param.name}"]`);

                            if (!existingField) {
                                // Если поле не существует, создаем его
                                console.log(`Добавляем параметр: ${param.name}=${value}`);
                                const hiddenField = document.createElement('input');
                                hiddenField.type = 'hidden';
                                hiddenField.name = param.name;
                                hiddenField.value = value;
                                form.appendChild(hiddenField);
                            } else {
                                // Если поле существует, обновляем его значение
                                console.log(`Обновляем параметр: ${param.name}=${value} (было: ${existingField.value})`);
                                existingField.value = value;
                            }
                        } else {
                            // Если элемент не найден, используем значение по умолчанию
                            console.log(`Элемент ${param.selector} не найден, используем значение по умолчанию: ${param.defaultValue}`);

                            // Проверяем, существует ли уже поле с таким именем
                            let existingField = form.querySelector(`input[name="${param.name}"]`);

                            if (!existingField) {
                                // Если поле не существует, создаем его с значением по умолчанию
                                console.log(`Добавляем параметр по умолчанию: ${param.name}=${param.defaultValue}`);
                                const hiddenField = document.createElement('input');
                                hiddenField.type = 'hidden';
                                hiddenField.name = param.name;
                                hiddenField.value = param.defaultValue;
                                form.appendChild(hiddenField);
                            }
                        }
                    });

// Дополнительная диагностика состояния формы перед отправкой
                    console.log('Финальное состояние формы перед отправкой:');
                    window.debugFormState();

                    console.log('Отправляем форму с актуальными параметрами');
                    // Отправляем форму программно
                    form.submit();

                    // Предотвращаем стандартное действие кнопки
                    event.preventDefault();
                });

                console.log('Прямой обработчик клика установлен');
            }
        }

// Вызываем настройку отладки в конце загрузки DOM
        setupDebugMonitoring();

    });
</script>
</body>
</html>